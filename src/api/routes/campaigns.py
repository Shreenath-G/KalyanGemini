"""Campaign management API routes"""

from fastapi import APIRouter, Depends, Request, status
from typing import Dict, Any
import logging
import uuid
from datetime import datetime

from src.models.campaign import Campaign, CampaignRequest, CampaignResponse, CampaignStatus, OptimizationMode
from src.api.dependencies import get_current_account_id
from src.api.errors import NotFoundError, ValidationError
from src.services.firestore import get_firestore_service
from src.agents.campaign_orchestrator import get_orchestrator_agent

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/v1/campaigns", tags=["Campaigns"])


@router.post(
    "",
    response_model=CampaignResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Create a new campaign",
    description="""Create a new advertising campaign with AI-powered strategy generation.
    
    This endpoint orchestrates multiple AI agents to:
    - Generate creative variations (headlines, body copy, CTAs)
    - Identify optimal audience segments
    - Allocate budget across platforms
    - Calculate optimal bid strategies
    
    **Authentication Required:** API Key in X-API-Key header
    
    **Rate Limit:** 100 requests per minute per account
    """,
    responses={
        201: {
            "description": "Campaign created successfully",
            "content": {
                "application/json": {
                    "example": {
                        "campaign_id": "camp_a1b2c3d4e5f6",
                        "status": "draft",
                        "estimated_launch": "2-4 hours",
                        "message": "Campaign created successfully. Strategy generated by AI agents."
                    }
                }
            }
        },
        400: {
            "description": "Validation error - invalid request parameters",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "VALIDATION_ERROR",
                            "message": "Request validation failed",
                            "details": "monthly_budget: must be between 100 and 100000"
                        }
                    }
                }
            }
        },
        401: {
            "description": "Authentication failed - invalid or missing API key",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "AUTHENTICATION_FAILED",
                            "message": "Invalid or missing API key",
                            "details": "Provide valid API key in X-API-Key header"
                        }
                    }
                }
            }
        },
        429: {
            "description": "Rate limit exceeded",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "RATE_LIMIT_EXCEEDED",
                            "message": "Too many requests",
                            "details": "Rate limit: 100 requests per minute",
                            "retry_after": 60
                        }
                    }
                }
            }
        }
    }
)
async def create_campaign(
    campaign_request: CampaignRequest,
    request: Request
) -> CampaignResponse:
    """
    Create a new advertising campaign
    
    This endpoint:
    1. Validates the campaign request
    2. Generates a unique campaign ID
    3. Initiates the campaign orchestrator agent
    4. Coordinates specialist agents (Creative, Audience, Budget)
    5. Returns campaign ID and estimated launch timeline
    
    Requirements: 1.1, 1.2, 14.1, 14.2, 14.3
    """
    account_id = get_current_account_id(request)
    
    if not account_id:
        raise ValidationError("Account ID not found in request")
    
    # Generate campaign ID
    campaign_id = f"camp_{uuid.uuid4().hex[:12]}"
    
    logger.info(
        f"Creating campaign",
        extra={
            "campaign_id": campaign_id,
            "account_id": account_id,
            "budget": campaign_request.monthly_budget,
            "goal": campaign_request.business_goal
        }
    )
    
    # Create campaign object
    campaign = Campaign(
        campaign_id=campaign_id,
        account_id=account_id,
        status=CampaignStatus.DRAFT,
        business_goal=campaign_request.business_goal,
        monthly_budget=campaign_request.monthly_budget,
        target_audience=campaign_request.target_audience,
        products=campaign_request.products,
        optimization_mode=campaign_request.optimization_mode
    )
    
    # Store campaign in Firestore
    firestore_service = get_firestore_service()
    await firestore_service.create_campaign(campaign)
    
    # Trigger Campaign Orchestrator Agent
    try:
        orchestrator = get_orchestrator_agent()
        
        # Handle campaign request with specialist agents
        agent_results = await orchestrator.handle_campaign_request(campaign, campaign_request)
        
        # Synthesize strategy from agent results
        updated_campaign = await orchestrator.synthesize_strategy(campaign, agent_results)
        
        # Determine estimated launch timeline
        estimated_launch = orchestrator._calculate_launch_timeline(
            updated_campaign,
            agent_results.get("requires_review", False)
        )
        
        # Prepare response message
        if agent_results.get("requires_review", False):
            message = "Campaign created with fallback strategies. Manual review recommended."
        else:
            message = "Campaign created successfully. Strategy generated by AI agents."
        
        logger.info(
            f"Campaign created and processed by orchestrator",
            extra={
                "campaign_id": campaign_id,
                "requires_review": agent_results.get("requires_review", False),
                "estimated_launch": estimated_launch
            }
        )
        
        return CampaignResponse(
            campaign_id=campaign_id,
            status=updated_campaign.status,
            estimated_launch=estimated_launch,
            message=message
        )
        
    except Exception as e:
        logger.error(
            f"Error processing campaign with orchestrator",
            extra={
                "campaign_id": campaign_id,
                "error": str(e)
            }
        )
        
        # Return response indicating processing will continue asynchronously
        return CampaignResponse(
            campaign_id=campaign_id,
            status=CampaignStatus.DRAFT,
            estimated_launch="24-48 hours",
            message="Campaign created. Strategy generation in progress."
        )


@router.get(
    "/{campaign_id}",
    response_model=Campaign,
    summary="Get campaign details",
    description="""Retrieve comprehensive information about a specific campaign.
    
    Returns complete campaign data including:
    - Campaign configuration (budget, goals, target audience)
    - AI-generated strategy (creative variants, audience segments, budget allocation)
    - Current performance metrics (spend, impressions, clicks, conversions, ROAS)
    - Optimization history
    
    **Authentication Required:** API Key in X-API-Key header
    
    **Authorization:** Only the campaign owner can access campaign details
    """,
    responses={
        200: {
            "description": "Campaign details retrieved successfully",
            "content": {
                "application/json": {
                    "example": {
                        "campaign_id": "camp_a1b2c3d4e5f6",
                        "account_id": "acc_123456",
                        "status": "active",
                        "business_goal": "increase_sales",
                        "monthly_budget": 5000.0,
                        "target_audience": "small business owners aged 30-50",
                        "products": ["CRM Software"],
                        "creative_variants": [
                            {
                                "variant_id": "var_001",
                                "headlines": {
                                    "short": "Save 50% Today",
                                    "medium": "Limited Time: Save 50% on Premium Plans",
                                    "long": "Don't Miss Out: Save 50% on All Premium Plans This Week Only"
                                },
                                "body": "Upgrade your business with our premium features.",
                                "cta": "Get Started Now",
                                "status": "active",
                                "roas": 3.2
                            }
                        ],
                        "total_spend": 1250.50,
                        "total_conversions": 45,
                        "current_roas": 2.8
                    }
                }
            }
        },
        401: {
            "description": "Authentication failed",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "AUTHENTICATION_FAILED",
                            "message": "Invalid or missing API key"
                        }
                    }
                }
            }
        },
        404: {
            "description": "Campaign not found or access denied",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "NOT_FOUND",
                            "message": "Campaign not found",
                            "details": "Campaign with ID 'camp_a1b2c3d4e5f6' does not exist"
                        }
                    }
                }
            }
        }
    }
)
async def get_campaign(
    campaign_id: str,
    request: Request
) -> Campaign:
    """
    Get campaign details by ID
    
    Returns complete campaign information including:
    - Campaign configuration
    - Generated strategy (creative variants, audience segments, budget allocation)
    - Current performance metrics
    
    Requirements: 1.2, 14.1, 14.2, 14.3
    """
    account_id = get_current_account_id(request)
    
    # Retrieve campaign from Firestore
    firestore_service = get_firestore_service()
    campaign = await firestore_service.get_campaign(campaign_id)
    
    if not campaign:
        logger.warning(f"Campaign not found: {campaign_id}")
        raise NotFoundError("Campaign", campaign_id)
    
    # Verify account ownership
    if campaign.account_id != account_id:
        logger.warning(
            f"Unauthorized access attempt",
            extra={
                "campaign_id": campaign_id,
                "requesting_account": account_id,
                "owner_account": campaign.account_id
            }
        )
        raise NotFoundError("Campaign", campaign_id)
    
    logger.info(f"Retrieved campaign: {campaign_id}")
    
    return campaign


@router.patch(
    "/{campaign_id}",
    response_model=Campaign,
    summary="Update campaign settings",
    description="""Update campaign configuration including budget, status, or optimization mode.
    
    **Updatable Fields:**
    - `budget`: Monthly budget ($100 - $100,000)
    - `status`: Campaign status (draft, active, paused, completed)
    - `optimization_mode`: Optimization aggressiveness (standard, aggressive)
    
    **Authentication Required:** API Key in X-API-Key header
    
    **Authorization:** Only the campaign owner can update campaign settings
    """,
    responses={
        200: {
            "description": "Campaign updated successfully",
            "content": {
                "application/json": {
                    "example": {
                        "campaign_id": "camp_a1b2c3d4e5f6",
                        "status": "active",
                        "monthly_budget": 7500.0,
                        "optimization_mode": "aggressive",
                        "message": "Campaign updated successfully"
                    }
                }
            }
        },
        400: {
            "description": "Validation error",
            "content": {
                "application/json": {
                    "example": {
                        "error": {
                            "code": "VALIDATION_ERROR",
                            "message": "Budget must be between $100 and $100,000",
                            "details": "Provided budget: $150000"
                        }
                    }
                }
            }
        },
        401: {
            "description": "Authentication failed"
        },
        404: {
            "description": "Campaign not found or access denied"
        }
    }
)
async def update_campaign(
    campaign_id: str,
    request: Request,
    budget: float = None,
    status_update: CampaignStatus = None,
    optimization_mode: OptimizationMode = None
) -> Campaign:
    """
    Update campaign settings
    
    Allows updating:
    - Monthly budget
    - Campaign status (active, paused, etc.)
    - Optimization mode (standard, aggressive)
    
    Requirements: 1.4, 14.1, 14.2, 14.3
    """
    account_id = get_current_account_id(request)
    
    # Retrieve campaign from Firestore
    firestore_service = get_firestore_service()
    campaign = await firestore_service.get_campaign(campaign_id)
    
    if not campaign:
        logger.warning(f"Campaign not found: {campaign_id}")
        raise NotFoundError("Campaign", campaign_id)
    
    # Verify account ownership
    if campaign.account_id != account_id:
        logger.warning(
            f"Unauthorized update attempt",
            extra={
                "campaign_id": campaign_id,
                "requesting_account": account_id,
                "owner_account": campaign.account_id
            }
        )
        raise NotFoundError("Campaign", campaign_id)
    
    # Build update dictionary
    update_dict = {}
    updates = []
    
    if budget is not None:
        if budget < 100.0 or budget > 100000.0:
            raise ValidationError(
                "Budget must be between $100 and $100,000",
                f"Provided budget: ${budget}"
            )
        update_dict["monthly_budget"] = budget
        campaign.monthly_budget = budget
        updates.append(f"budget=${budget}")
    
    if status_update is not None:
        update_dict["status"] = status_update.value
        campaign.status = status_update
        updates.append(f"status={status_update}")
    
    if optimization_mode is not None:
        update_dict["optimization_mode"] = optimization_mode.value
        campaign.optimization_mode = optimization_mode
        updates.append(f"optimization_mode={optimization_mode}")
    
    # Update in Firestore
    if update_dict:
        await firestore_service.update_campaign(campaign_id, update_dict)
    
    logger.info(
        f"Campaign updated",
        extra={
            "campaign_id": campaign_id,
            "updates": ", ".join(updates)
        }
    )
    
    # TODO: Notify agents of campaign updates
    # This will be implemented when agent communication is set up
    
    return campaign


@router.delete(
    "/{campaign_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete campaign",
    description="Delete a campaign (soft delete - marks as completed)"
)
async def delete_campaign(
    campaign_id: str,
    request: Request
) -> None:
    """
    Delete (complete) a campaign
    
    This performs a soft delete by marking the campaign as completed.
    Campaign data is retained for reporting purposes.
    """
    account_id = get_current_account_id(request)
    
    # Retrieve campaign from Firestore
    firestore_service = get_firestore_service()
    campaign = await firestore_service.get_campaign(campaign_id)
    
    if not campaign:
        logger.warning(f"Campaign not found: {campaign_id}")
        raise NotFoundError("Campaign", campaign_id)
    
    # Verify account ownership
    if campaign.account_id != account_id:
        logger.warning(
            f"Unauthorized delete attempt",
            extra={
                "campaign_id": campaign_id,
                "requesting_account": account_id,
                "owner_account": campaign.account_id
            }
        )
        raise NotFoundError("Campaign", campaign_id)
    
    # Soft delete - mark as completed in Firestore
    await firestore_service.update_campaign(campaign_id, {"status": CampaignStatus.COMPLETED.value})
    
    logger.info(f"Campaign deleted (marked as completed): {campaign_id}")
    
    # TODO: Notify agents to stop processing this campaign
    
    return None


@router.get(
    "",
    response_model=Dict[str, Any],
    summary="List campaigns",
    description="List all campaigns for the authenticated account"
)
async def list_campaigns(
    request: Request,
    status_filter: CampaignStatus = None,
    limit: int = 50,
    offset: int = 0
) -> Dict[str, Any]:
    """
    List campaigns for the authenticated account
    
    Supports filtering by status and pagination
    """
    account_id = get_current_account_id(request)
    
    # Get campaigns from Firestore
    firestore_service = get_firestore_service()
    account_campaigns = await firestore_service.get_campaigns_by_account(account_id, status_filter)
    
    # Sort by creation date (newest first)
    account_campaigns.sort(key=lambda c: c.created_at, reverse=True)
    
    # Apply pagination
    total = len(account_campaigns)
    paginated_campaigns = account_campaigns[offset:offset + limit]
    
    logger.info(
        f"Listed campaigns",
        extra={
            "account_id": account_id,
            "total": total,
            "returned": len(paginated_campaigns)
        }
    )
    
    return {
        "campaigns": paginated_campaigns,
        "total": total,
        "limit": limit,
        "offset": offset,
        "has_more": offset + limit < total
    }
