# Developer Guide: Adaptive Ad Intelligence Platform

## Table of Contents

1. [Getting Started](#getting-started)
2. [Core Concepts](#core-concepts)
3. [Campaign Optimization Best Practices](#campaign-optimization-best-practices)
4. [Troubleshooting](#troubleshooting)
5. [Performance Tuning](#performance-tuning)
6. [Security Best Practices](#security-best-practices)
7. [Advanced Topics](#advanced-topics)

---

## Getting Started

### Prerequisites

Before you begin, ensure you have:

- **API Key**: Sign up at [https://platform.example.com](https://platform.example.com)
- **Development Environment**: Python 3.8+ or Node.js 14+
- **Basic Understanding**: REST APIs, JSON, and HTTP methods
- **Budget**: Minimum $100/month for campaign testing

### Installation

#### Python

```bash
# Install the official SDK
pip install ad-intelligence-sdk

# Or use requests library
pip install requests
```

#### JavaScript/Node.js

```bash
# Install the official SDK
npm install @ad-intelligence/sdk

# Or use axios
npm install axios
```

### Quick Start: Your First Campaign

#### Step 1: Initialize the Client

**Python:**
```python
from ad_intelligence_sdk import AdIntelligenceClient

client = AdIntelligenceClient(
    api_key="your_api_key_here",
    base_url="https://api.example.com"
)
```


**JavaScript:**
```javascript
const { AdIntelligenceClient } = require('@ad-intelligence/sdk');

const client = new AdIntelligenceClient({
    apiKey: 'your_api_key_here',
    baseUrl: 'https://api.example.com'
});
```

#### Step 2: Create Your First Campaign

**Python:**
```python
# Define campaign parameters
campaign = client.create_campaign(
    business_goal="increase_sales",
    monthly_budget=5000.0,
    target_audience="small business owners aged 30-50 interested in productivity tools",
    products=["Project Management Software"],
    optimization_mode="standard"
)

print(f"Campaign created: {campaign['campaign_id']}")
print(f"Status: {campaign['status']}")
print(f"Estimated launch: {campaign['estimated_launch']}")
```

**JavaScript:**
```javascript
// Define campaign parameters
const campaign = await client.createCampaign({
    businessGoal: 'increase_sales',
    monthlyBudget: 5000.0,
    targetAudience: 'small business owners aged 30-50 interested in productivity tools',
    products: ['Project Management Software'],
    optimizationMode: 'standard'
});

console.log(`Campaign created: ${campaign.campaign_id}`);
console.log(`Status: ${campaign.status}`);
console.log(`Estimated launch: ${campaign.estimated_launch}`);
```

#### Step 3: Wait for Campaign to Be Ready

The AI agents need 15-30 seconds to generate your campaign strategy:

**Python:**
```python
import time

# Poll until campaign is active
max_attempts = 12
for attempt in range(max_attempts):
    status = client.get_campaign(campaign['campaign_id'])
    
    if status['status'] == 'active':
        print("Campaign is live!")
        break
    elif status['status'] == 'failed':
        print(f"Campaign failed: {status.get('error_message')}")
        break
    
    print(f"Status: {status['status']}... waiting")
    time.sleep(5)
```


#### Step 4: Monitor Performance

Check campaign performance after it's been running:

**Python:**
```python
# Get performance metrics
metrics = client.get_performance(campaign['campaign_id'])

print(f"Spend: ${metrics['total_spend']:.2f}")
print(f"Conversions: {metrics['total_conversions']}")
print(f"ROAS: {metrics['roas']:.2f}x")
print(f"CPA: ${metrics['cpa']:.2f}")
print(f"CTR: {metrics['ctr']:.2%}")
```

#### Step 5: Optimize Your Campaign

Let the AI optimize your campaign automatically:

**Python:**
```python
# Trigger automatic optimization
result = client.optimize_campaign(
    campaign['campaign_id'],
    optimization_type='auto'
)

print(f"Optimization complete: {result['message']}")
print(f"Actions taken: {len(result['actions'])}")

for action in result['actions']:
    print(f"  - {action['type']}: {action['description']}")
```

### Understanding the Response

When you create a campaign, you'll receive:

```json
{
  "campaign_id": "camp_a1b2c3d4e5f6",
  "status": "draft",
  "estimated_launch": "2024-01-15T10:30:00Z",
  "message": "Campaign strategy is being generated by AI agents",
  "strategy_preview": {
    "creative_variants": 5,
    "audience_segments": 3,
    "platforms": ["google_ads", "meta_ads", "programmatic"]
  }
}
```

**Status Values:**
- `draft`: AI agents are generating strategy (15-30 seconds)
- `active`: Campaign is live and running
- `paused`: Campaign is paused (can be resumed)
- `completed`: Campaign has ended
- `failed`: Campaign creation failed (check error_message)

---

## Core Concepts

### Multi-Agent Architecture

The platform uses six specialized AI agents that work together:


1. **Campaign Orchestrator Agent**: Coordinates all other agents and synthesizes the final strategy
2. **Creative Generator Agent**: Generates ad copy variations (headlines, body, CTAs)
3. **Audience Targeting Agent**: Identifies optimal audience segments
4. **Budget Optimizer Agent**: Allocates spend across platforms and segments
5. **Performance Analyzer Agent**: Monitors metrics and triggers optimizations
6. **Bid Execution Agent**: Executes real-time programmatic bids

### Campaign Lifecycle

```
Create ‚Üí Draft (AI Processing) ‚Üí Active ‚Üí Optimizing ‚Üí Completed
                    ‚Üì
                  Failed
```

**Typical Timeline:**
- **0-30 seconds**: AI agents generate strategy
- **Day 1-2**: Testing phase (20% of budget)
- **Day 3+**: Optimization phase (automatic adjustments)
- **Week 1**: First major optimization review
- **Ongoing**: Continuous monitoring and optimization

### Budget Allocation Strategy

The platform automatically allocates your budget:

- **80%**: Main budget distributed across audience segments
- **20%**: Testing budget for new audiences and creatives

**Platform Split (default):**
- **40%**: Google Ads
- **40%**: Meta Ads (Facebook/Instagram)
- **20%**: Programmatic exchanges

### Performance Metrics

Key metrics tracked:

- **ROAS** (Return on Ad Spend): Revenue √∑ Ad Spend
  - Target: > 3.0x for profitable campaigns
  - Warning: < 1.0x means losing money

- **CPA** (Cost Per Acquisition): Ad Spend √∑ Conversions
  - Lower is better
  - Compare against customer lifetime value

- **CTR** (Click-Through Rate): Clicks √∑ Impressions
  - Industry average: 2-5%
  - Higher CTR = more relevant ads

- **Conversion Rate**: Conversions √∑ Clicks
  - Industry average: 2-10%
  - Depends on product and landing page quality

---

## Campaign Optimization Best Practices

### 1. Set Clear Goals

Define specific, measurable goals before creating campaigns:


**Good Goals:**
- "Generate 100 qualified leads at $50 CPA or less"
- "Achieve 3.5x ROAS on $5,000 monthly budget"
- "Increase website traffic by 50% with CTR > 3%"

**Poor Goals:**
- "Get more customers" (not measurable)
- "Increase brand awareness" (hard to track)
- "Spend less money" (contradicts growth)

### 2. Provide Detailed Audience Descriptions

The more specific your target audience description, the better the AI can optimize:

**Good Description:**
```python
target_audience = """
Small business owners aged 30-50 with 5-50 employees, 
interested in productivity tools and business automation. 
They are tech-savvy, value time-saving solutions, and 
have budgets of $100-500/month for software tools.
"""
```

**Poor Description:**
```python
target_audience = "business owners"  # Too vague
```

### 3. Start with Adequate Budget

**Minimum Recommendations:**
- **Testing Phase**: $500-1,000 for initial data collection
- **Optimization Phase**: $2,000-5,000 for meaningful results
- **Scale Phase**: $5,000+ for maximum impact

**Budget Too Low?**
- Insufficient data for optimization
- Limited reach and frequency
- Longer time to profitability

### 4. Allow Time for Learning

**Week 1**: Testing and data collection
- AI tests different creatives and audiences
- Performance may be volatile
- Don't make manual changes yet

**Week 2-3**: Initial optimization
- AI identifies winning combinations
- Performance stabilizes
- Budget shifts to top performers

**Week 4+**: Mature optimization
- Consistent performance
- Continuous refinement
- Scale successful campaigns

### 5. Monitor Key Thresholds

Set up alerts for these critical thresholds:


**Python Example:**
```python
def check_campaign_health(campaign_id):
    metrics = client.get_performance(campaign_id)
    alerts = []
    
    # Check ROAS
    if metrics['roas'] < 1.0:
        alerts.append(f"‚ö†Ô∏è Low ROAS: {metrics['roas']:.2f}x (losing money)")
    elif metrics['roas'] < 1.5:
        alerts.append(f"‚ö†Ô∏è Below target ROAS: {metrics['roas']:.2f}x")
    
    # Check CPA
    target_cpa = 50.0  # Your target
    if metrics['cpa'] > target_cpa * 1.5:
        alerts.append(f"‚ö†Ô∏è High CPA: ${metrics['cpa']:.2f} (target: ${target_cpa})")
    
    # Check CTR
    if metrics['ctr'] < 0.02:  # 2%
        alerts.append(f"‚ö†Ô∏è Low CTR: {metrics['ctr']:.2%} (ads may not be relevant)")
    
    # Check spend rate
    days_elapsed = 7  # Example
    expected_spend = (metrics['total_budget'] / 30) * days_elapsed
    if metrics['total_spend'] < expected_spend * 0.5:
        alerts.append(f"‚ö†Ô∏è Underspending: ${metrics['total_spend']:.2f} (expected: ${expected_spend:.2f})")
    
    return alerts

# Run daily
alerts = check_campaign_health('camp_123')
if alerts:
    for alert in alerts:
        print(alert)
        send_notification(alert)
```

### 6. Use Optimization Modes Wisely

**Standard Mode** (Recommended for most):
- Balanced approach
- Daily budget adjustments
- Pauses variants with ROAS < 0.5
- Scales variants with ROAS > 4.0

**Aggressive Mode** (For experienced users):
- More frequent adjustments (every 6 hours)
- Faster budget reallocation
- Higher risk, higher reward
- Best for time-sensitive campaigns

```python
# Switch to aggressive mode for Black Friday
client.update_campaign(
    campaign_id,
    optimization_mode='aggressive'
)
```

### 7. Leverage Performance Breakdowns

Analyze performance by different dimensions:


**Python Example:**
```python
# Get detailed performance breakdown
metrics = client.get_performance(campaign_id)

# Analyze by creative variant
print("\nüìä Top Performing Creatives:")
variants = sorted(metrics['by_variant'], key=lambda x: x['roas'], reverse=True)
for variant in variants[:3]:
    print(f"  {variant['variant_id']}: ROAS {variant['roas']:.2f}x, {variant['conversions']} conversions")

# Analyze by audience segment
print("\nüéØ Top Performing Audiences:")
segments = sorted(metrics['by_segment'], key=lambda x: x['roas'], reverse=True)
for segment in segments[:3]:
    print(f"  {segment['name']}: ROAS {segment['roas']:.2f}x, CPA ${segment['cpa']:.2f}")

# Analyze by platform
print("\nüì± Platform Performance:")
for platform, data in metrics['by_platform'].items():
    print(f"  {platform}: ROAS {data['roas']:.2f}x, Spend ${data['spend']:.2f}")
```

### 8. Test and Iterate

Continuously test new approaches:

**A/B Testing Example:**
```python
# Create two campaigns with different approaches
campaign_a = client.create_campaign(
    business_goal="increase_sales",
    monthly_budget=2500.0,
    target_audience="small business owners",
    products=["CRM Software - Professional Plan"],
    optimization_mode="standard"
)

campaign_b = client.create_campaign(
    business_goal="increase_sales",
    monthly_budget=2500.0,
    target_audience="enterprise decision makers",
    products=["CRM Software - Enterprise Plan"],
    optimization_mode="aggressive"
)

# Compare after 2 weeks
def compare_campaigns(campaign_a_id, campaign_b_id):
    metrics_a = client.get_performance(campaign_a_id)
    metrics_b = client.get_performance(campaign_b_id)
    
    print(f"Campaign A: ROAS {metrics_a['roas']:.2f}x, CPA ${metrics_a['cpa']:.2f}")
    print(f"Campaign B: ROAS {metrics_b['roas']:.2f}x, CPA ${metrics_b['cpa']:.2f}")
    
    # Scale the winner
    if metrics_a['roas'] > metrics_b['roas']:
        client.update_campaign(campaign_a_id, budget=5000.0)
        print("Scaling Campaign A")
    else:
        client.update_campaign(campaign_b_id, budget=5000.0)
        print("Scaling Campaign B")
```

### 9. Optimize Landing Pages

Campaign performance depends heavily on landing page quality:


**Landing Page Checklist:**
- ‚úÖ Fast load time (< 3 seconds)
- ‚úÖ Mobile-responsive design
- ‚úÖ Clear value proposition above the fold
- ‚úÖ Strong call-to-action button
- ‚úÖ Trust signals (testimonials, logos, reviews)
- ‚úÖ Simple form (fewer fields = higher conversion)
- ‚úÖ Consistent messaging with ad copy

**Track Landing Page Performance:**
```python
# If you have conversion tracking
metrics = client.get_performance(campaign_id)

# Calculate landing page conversion rate
landing_page_cvr = metrics['total_conversions'] / metrics['total_clicks']
print(f"Landing Page CVR: {landing_page_cvr:.2%}")

# Industry benchmarks:
# - SaaS: 5-10%
# - E-commerce: 2-5%
# - Lead gen: 10-20%
```

### 10. Schedule Regular Reviews

Establish a review cadence:

**Daily** (5 minutes):
- Check for critical alerts
- Review spend pacing
- Monitor ROAS trends

**Weekly** (30 minutes):
- Analyze performance breakdowns
- Review optimization actions
- Adjust budgets if needed

**Monthly** (2 hours):
- Comprehensive performance review
- Strategic planning for next month
- Budget reallocation across campaigns

---

## Troubleshooting

### Common Issues and Solutions

#### Issue 1: Campaign Stuck in "Draft" Status

**Symptoms:**
- Campaign status remains "draft" for > 2 minutes
- No error message returned

**Possible Causes:**
1. AI agents are still processing (normal up to 30 seconds)
2. Agent timeout or failure
3. Invalid campaign parameters

**Solutions:**


```python
# Solution 1: Wait longer and check for errors
import time

campaign_id = campaign['campaign_id']
for attempt in range(15):  # Wait up to 75 seconds
    status = client.get_campaign(campaign_id)
    
    if status['status'] != 'draft':
        break
    
    if 'error_message' in status:
        print(f"Error: {status['error_message']}")
        break
    
    time.sleep(5)

# Solution 2: Check system health
health = client.get_health()
if health['status'] != 'healthy':
    print(f"System issue: {health['agents_status']}")

# Solution 3: Retry with simplified parameters
if status['status'] == 'draft' and attempt >= 14:
    print("Campaign creation timed out, retrying...")
    campaign = client.create_campaign(
        business_goal="increase_sales",
        monthly_budget=5000.0,
        target_audience="general audience",  # Simplified
        products=["Product Name"]
    )
```

#### Issue 2: Low ROAS (< 1.0)

**Symptoms:**
- Campaign is losing money
- ROAS consistently below 1.0
- High spend, low conversions

**Possible Causes:**
1. Poor product-market fit
2. Weak landing page
3. Incorrect audience targeting
4. Insufficient budget for testing
5. Unrealistic pricing

**Solutions:**

```python
# Solution 1: Analyze performance breakdown
metrics = client.get_performance(campaign_id)

# Find worst performers
variants = sorted(metrics['by_variant'], key=lambda x: x['roas'])
print("Worst performing creatives:")
for variant in variants[:3]:
    print(f"  {variant['variant_id']}: ROAS {variant['roas']:.2f}x")

# Solution 2: Pause campaign and review strategy
client.update_campaign(campaign_id, status='paused')

# Review and adjust:
# - Improve landing page conversion rate
# - Refine target audience
# - Adjust product pricing
# - Increase budget for better data

# Solution 3: Trigger aggressive optimization
result = client.optimize_campaign(
    campaign_id,
    optimization_type='auto'
)
```


#### Issue 3: Rate Limit Errors (429)

**Symptoms:**
- HTTP 429 status code
- Error message: "Rate limit exceeded"
- Requests failing intermittently

**Possible Causes:**
1. Exceeding 100 requests/minute limit
2. Burst of requests without throttling
3. Multiple clients using same API key

**Solutions:**

```python
# Solution 1: Implement exponential backoff
import time
from requests.exceptions import HTTPError

def api_call_with_retry(func, *args, max_retries=3, **kwargs):
    for attempt in range(max_retries):
        try:
            return func(*args, **kwargs)
        except HTTPError as e:
            if e.response.status_code == 429:
                retry_after = int(e.response.headers.get('Retry-After', 60))
                print(f"Rate limited. Waiting {retry_after} seconds...")
                time.sleep(retry_after)
            else:
                raise
    
    raise Exception("Max retries exceeded")

# Usage
campaign = api_call_with_retry(
    client.create_campaign,
    business_goal="increase_sales",
    monthly_budget=5000.0,
    target_audience="small business owners",
    products=["CRM Software"]
)

# Solution 2: Implement request throttling
import time
from collections import deque

class RateLimiter:
    def __init__(self, max_requests=90, time_window=60):
        self.max_requests = max_requests
        self.time_window = time_window
        self.requests = deque()
    
    def wait_if_needed(self):
        now = time.time()
        
        # Remove old requests outside time window
        while self.requests and self.requests[0] < now - self.time_window:
            self.requests.popleft()
        
        # Wait if at limit
        if len(self.requests) >= self.max_requests:
            sleep_time = self.time_window - (now - self.requests[0])
            if sleep_time > 0:
                time.sleep(sleep_time)
        
        self.requests.append(time.time())

# Usage
limiter = RateLimiter()

for campaign_id in campaign_ids:
    limiter.wait_if_needed()
    metrics = client.get_performance(campaign_id)
```


#### Issue 4: Agent Timeout Errors (504)

**Symptoms:**
- HTTP 504 status code
- Error: "Agent did not respond in time"
- Campaign creation fails

**Possible Causes:**
1. High system load
2. Complex campaign parameters
3. Temporary agent unavailability

**Solutions:**

```python
# Solution 1: Retry with exponential backoff
def create_campaign_with_retry(max_retries=3, **params):
    for attempt in range(max_retries):
        try:
            return client.create_campaign(**params)
        except HTTPError as e:
            if e.response.status_code == 504:
                wait_time = 2 ** attempt  # 1s, 2s, 4s
                print(f"Agent timeout. Retrying in {wait_time}s...")
                time.sleep(wait_time)
            else:
                raise
    
    raise Exception("Campaign creation failed after retries")

# Solution 2: Simplify campaign parameters
# Instead of complex audience description
target_audience = """
Small business owners aged 30-50 with 5-50 employees,
interested in productivity tools and business automation,
tech-savvy, value time-saving solutions, budgets $100-500/month
"""

# Use simpler description
target_audience = "small business owners interested in productivity tools"

# Solution 3: Check system status first
health = client.get_health()
if 'agents_status' in health:
    for agent, status in health['agents_status'].items():
        if status != 'healthy':
            print(f"Warning: {agent} is {status}")
```

#### Issue 5: No Conversions After 1 Week

**Symptoms:**
- Campaign is active and spending
- Getting clicks but no conversions
- Conversion tracking appears broken

**Possible Causes:**
1. Conversion tracking not implemented
2. Landing page issues
3. Poor product-market fit
4. Unrealistic expectations

**Solutions:**


```python
# Solution 1: Verify conversion tracking
metrics = client.get_performance(campaign_id)

print(f"Clicks: {metrics['total_clicks']}")
print(f"Conversions: {metrics['total_conversions']}")
print(f"Conversion Rate: {metrics['total_conversions'] / metrics['total_clicks']:.2%}")

# If clicks > 0 but conversions = 0, check:
# 1. Is conversion tracking pixel installed?
# 2. Is the conversion goal defined correctly?
# 3. Are users completing the desired action?

# Solution 2: Analyze click-through behavior
# Check if users are bouncing immediately
if metrics['total_clicks'] > 100 and metrics['total_conversions'] == 0:
    print("‚ö†Ô∏è High clicks, no conversions - check landing page")
    print("Recommendations:")
    print("  - Verify conversion tracking is installed")
    print("  - Test landing page load time")
    print("  - Review landing page messaging")
    print("  - Simplify conversion form")

# Solution 3: Lower the conversion barrier
# If selling high-ticket items, consider:
# - Offering free trial instead of purchase
# - Collecting leads instead of sales
# - Providing free consultation
```

#### Issue 6: Budget Spending Too Fast

**Symptoms:**
- Daily budget exhausted in first few hours
- Campaign pauses due to budget limits
- Inconsistent delivery throughout day

**Possible Causes:**
1. Bids set too high
2. Audience too broad
3. High competition for keywords
4. Budget too low for audience size

**Solutions:**

```python
# Solution 1: Check bid statistics
bid_stats = client.get_bid_stats(campaign_id)

print(f"Average bid: ${bid_stats['avg_bid']:.2f}")
print(f"Win rate: {bid_stats['win_rate']:.2%}")

# If win rate > 60%, bids may be too high
if bid_stats['win_rate'] > 0.60:
    print("‚ö†Ô∏è Win rate too high - reducing bids")
    # System will auto-adjust, or manually optimize
    client.optimize_campaign(campaign_id, optimization_type='auto')

# Solution 2: Increase daily budget
current_budget = metrics['total_budget'] / 30  # Monthly to daily
recommended_budget = current_budget * 1.5

client.update_campaign(
    campaign_id,
    budget=metrics['total_budget'] * 1.5
)

# Solution 3: Narrow audience targeting
# Pause campaign and recreate with more specific audience
client.update_campaign(campaign_id, status='paused')
```


#### Issue 7: Authentication Errors (401)

**Symptoms:**
- HTTP 401 status code
- Error: "Authentication failed"
- All requests failing

**Possible Causes:**
1. Invalid API key
2. API key expired or revoked
3. Incorrect header format
4. API key not activated

**Solutions:**

```python
# Solution 1: Verify API key format
api_key = "your_api_key_here"

# Check if key looks valid (should be alphanumeric)
if not api_key or len(api_key) < 20:
    print("‚ö†Ô∏è API key appears invalid")

# Solution 2: Test with health endpoint (no auth required)
import requests

response = requests.get("https://api.example.com/api/health")
if response.status_code == 200:
    print("‚úÖ API is reachable")
else:
    print("‚ùå API is not reachable")

# Solution 3: Verify header format
headers = {
    'X-API-Key': api_key,  # Correct header name
    'Content-Type': 'application/json'
}

# Solution 4: Generate new API key
# Log into platform and generate new key
# Update your configuration
```

### Debugging Tips

#### Enable Debug Logging

**Python:**
```python
import logging

# Enable debug logging
logging.basicConfig(level=logging.DEBUG)

# SDK will now log all requests and responses
client = AdIntelligenceClient(
    api_key="your_api_key",
    debug=True
)
```

#### Inspect Raw API Responses

**Python:**
```python
import requests

response = requests.post(
    "https://api.example.com/api/v1/campaigns",
    headers={'X-API-Key': 'your_api_key'},
    json={
        'business_goal': 'increase_sales',
        'monthly_budget': 5000.0,
        'target_audience': 'small business owners',
        'products': ['CRM Software']
    }
)

print(f"Status: {response.status_code}")
print(f"Headers: {response.headers}")
print(f"Body: {response.text}")
```


#### Use API Monitoring Tools

**Postman Collection:**
```bash
# Import our Postman collection
https://www.postman.com/example/collections/ad-intelligence-api
```

**cURL for Quick Testing:**
```bash
# Test health endpoint
curl -X GET "https://api.example.com/api/health"

# Test authentication
curl -X GET "https://api.example.com/api/v1/campaigns" \
  -H "X-API-Key: your_api_key" \
  -v  # Verbose output for debugging
```

---

## Performance Tuning

### Optimize API Call Patterns

#### Batch Operations

Instead of making individual calls, batch when possible:

**‚ùå Inefficient:**
```python
# Making 10 separate API calls
for campaign_id in campaign_ids:
    metrics = client.get_performance(campaign_id)
    process_metrics(metrics)
```

**‚úÖ Efficient:**
```python
# Use list endpoint with filtering
campaigns = client.list_campaigns(status='active')

for campaign in campaigns['campaigns']:
    # Data already includes basic metrics
    process_metrics(campaign)
```

#### Cache Frequently Accessed Data

**Python Example:**
```python
from functools import lru_cache
import time

class CachedClient:
    def __init__(self, client):
        self.client = client
        self._cache = {}
        self._cache_ttl = 300  # 5 minutes
    
    def get_campaign(self, campaign_id):
        cache_key = f"campaign_{campaign_id}"
        
        if cache_key in self._cache:
            data, timestamp = self._cache[cache_key]
            if time.time() - timestamp < self._cache_ttl:
                return data
        
        # Fetch from API
        data = self.client.get_campaign(campaign_id)
        self._cache[cache_key] = (data, time.time())
        
        return data

# Usage
cached_client = CachedClient(client)
campaign = cached_client.get_campaign('camp_123')  # Cached for 5 min
```


#### Use Webhooks Instead of Polling

**‚ùå Inefficient Polling:**
```python
# Polling every 5 seconds
while True:
    campaign = client.get_campaign(campaign_id)
    if campaign['status'] == 'active':
        break
    time.sleep(5)
```

**‚úÖ Efficient Webhook:**
```python
from fastapi import FastAPI, Request

app = FastAPI()

@app.post("/webhook/campaign-update")
async def handle_campaign_update(request: Request):
    data = await request.json()
    
    if data['status'] == 'active':
        # Campaign is ready
        process_campaign(data['campaign_id'])
    
    return {"success": True}

# Register webhook with platform
client.register_webhook(
    url="https://your-domain.com/webhook/campaign-update",
    events=['campaign.created', 'campaign.updated']
)
```

### Optimize Campaign Performance

#### Reduce Creative Fatigue

Refresh creatives regularly to maintain performance:

```python
def refresh_campaign_creatives(campaign_id):
    metrics = client.get_performance(campaign_id)
    
    # Check if creatives are getting stale
    for variant in metrics['by_variant']:
        # If CTR declining over time
        if variant['ctr_trend'] == 'declining':
            print(f"Refreshing variant {variant['variant_id']}")
            
            # Trigger new creative generation
            client.optimize_campaign(
                campaign_id,
                optimization_type='generate_new_creatives'
            )
            break

# Run weekly
scheduler.add_job(
    refresh_campaign_creatives,
    args=[campaign_id],
    trigger='cron',
    day_of_week='mon'
)
```

#### Optimize Bid Strategy

Monitor and adjust bid strategy based on win rates:

```python
def optimize_bid_strategy(campaign_id):
    bid_stats = client.get_bid_stats(campaign_id)
    
    # Target win rate: 20-40%
    if bid_stats['win_rate'] < 0.20:
        print("Win rate too low - increasing bids")
        # System auto-adjusts, or trigger optimization
        client.optimize_campaign(campaign_id, optimization_type='auto')
    
    elif bid_stats['win_rate'] > 0.40:
        print("Win rate too high - decreasing bids")
        client.optimize_campaign(campaign_id, optimization_type='auto')
```

---

## Security Best Practices

### 1. Protect Your API Key


**‚ùå Never do this:**
```python
# Hardcoded in source code
api_key = "sk_live_abc123xyz789"

# Committed to version control
# Exposed in client-side code
# Shared in public forums
```

**‚úÖ Best practices:**
```python
# Use environment variables
import os
api_key = os.environ.get('AD_INTELLIGENCE_API_KEY')

# Or use a secrets manager
from google.cloud import secretmanager
client = secretmanager.SecretManagerServiceClient()
secret = client.access_secret_version(name="projects/PROJECT_ID/secrets/api-key/versions/latest")
api_key = secret.payload.data.decode('UTF-8')

# Or use a .env file (not committed to git)
from dotenv import load_dotenv
load_dotenv()
api_key = os.getenv('AD_INTELLIGENCE_API_KEY')
```

### 2. Rotate API Keys Regularly

```python
# Rotate keys every 90 days
def rotate_api_key():
    # Generate new key via platform
    new_key = platform.generate_new_api_key()
    
    # Update in secrets manager
    update_secret('AD_INTELLIGENCE_API_KEY', new_key)
    
    # Revoke old key after grace period
    time.sleep(3600)  # 1 hour grace period
    platform.revoke_api_key(old_key)
```

### 3. Implement Request Signing

For webhook endpoints, verify signatures:

```python
import hmac
import hashlib

def verify_webhook_signature(payload, signature, secret):
    expected = hmac.new(
        secret.encode(),
        payload.encode(),
        hashlib.sha256
    ).hexdigest()
    
    return hmac.compare_digest(signature, expected)

@app.post("/webhook/campaign-update")
async def handle_webhook(request: Request):
    signature = request.headers.get('X-Webhook-Signature')
    payload = await request.body()
    
    if not verify_webhook_signature(payload.decode(), signature, WEBHOOK_SECRET):
        raise HTTPException(status_code=401, detail="Invalid signature")
    
    # Process webhook
    data = await request.json()
    process_update(data)
```

### 4. Use HTTPS Only

```python
# Always use HTTPS endpoints
client = AdIntelligenceClient(
    api_key=api_key,
    base_url="https://api.example.com"  # Not http://
)
```

### 5. Implement IP Whitelisting

Configure IP restrictions in the platform dashboard:

```
Allowed IPs:
- 203.0.113.0/24 (Production servers)
- 198.51.100.50 (CI/CD pipeline)
```


### 6. Monitor for Suspicious Activity

```python
def monitor_api_usage():
    # Get usage statistics
    usage = client.get_usage_stats()
    
    # Alert on unusual patterns
    if usage['requests_last_hour'] > usage['avg_requests_per_hour'] * 3:
        alert.send("‚ö†Ô∏è Unusual API activity detected")
    
    if usage['failed_requests'] > usage['total_requests'] * 0.1:
        alert.send("‚ö†Ô∏è High error rate detected")
```

---

## Advanced Topics

### Multi-Account Management

Manage multiple client accounts:

```python
class MultiAccountManager:
    def __init__(self):
        self.clients = {}
    
    def add_account(self, account_id, api_key):
        self.clients[account_id] = AdIntelligenceClient(api_key=api_key)
    
    def get_all_performance(self):
        results = {}
        
        for account_id, client in self.clients.items():
            campaigns = client.list_campaigns(status='active')
            
            total_spend = 0
            total_roas = 0
            
            for campaign in campaigns['campaigns']:
                metrics = client.get_performance(campaign['campaign_id'])
                total_spend += metrics['total_spend']
                total_roas += metrics['roas']
            
            results[account_id] = {
                'total_spend': total_spend,
                'avg_roas': total_roas / len(campaigns['campaigns']) if campaigns['campaigns'] else 0
            }
        
        return results

# Usage
manager = MultiAccountManager()
manager.add_account('account_1', 'api_key_1')
manager.add_account('account_2', 'api_key_2')

performance = manager.get_all_performance()
```

### Custom Reporting Dashboards

Build custom dashboards with real-time data:

```python
from flask import Flask, render_template
import plotly.graph_objs as go

app = Flask(__name__)

@app.route('/dashboard')
def dashboard():
    campaigns = client.list_campaigns(status='active')
    
    # Prepare data for visualization
    campaign_names = []
    roas_values = []
    spend_values = []
    
    for campaign in campaigns['campaigns']:
        metrics = client.get_performance(campaign['campaign_id'])
        campaign_names.append(campaign['campaign_id'][:8])
        roas_values.append(metrics['roas'])
        spend_values.append(metrics['total_spend'])
    
    # Create charts
    roas_chart = go.Bar(x=campaign_names, y=roas_values, name='ROAS')
    spend_chart = go.Bar(x=campaign_names, y=spend_values, name='Spend')
    
    return render_template('dashboard.html', 
                         roas_chart=roas_chart,
                         spend_chart=spend_chart)
```


### Automated Budget Management

Implement intelligent budget allocation:

```python
class BudgetManager:
    def __init__(self, client, total_budget):
        self.client = client
        self.total_budget = total_budget
    
    def allocate_budget(self):
        campaigns = self.client.list_campaigns(status='active')
        
        # Calculate performance scores
        scores = []
        for campaign in campaigns['campaigns']:
            metrics = self.client.get_performance(campaign['campaign_id'])
            
            # Score = ROAS * sqrt(conversions)
            score = metrics['roas'] * (metrics['total_conversions'] ** 0.5)
            
            scores.append({
                'campaign_id': campaign['campaign_id'],
                'score': score,
                'current_budget': campaign['monthly_budget']
            })
        
        # Allocate budget proportionally
        total_score = sum(s['score'] for s in scores)
        
        for campaign_score in scores:
            new_budget = self.total_budget * (campaign_score['score'] / total_score)
            
            # Don't change budget by more than 50% at once
            max_change = campaign_score['current_budget'] * 0.5
            budget_change = new_budget - campaign_score['current_budget']
            
            if abs(budget_change) > max_change:
                new_budget = campaign_score['current_budget'] + (max_change if budget_change > 0 else -max_change)
            
            # Update campaign
            self.client.update_campaign(
                campaign_score['campaign_id'],
                budget=new_budget
            )
            
            print(f"Updated {campaign_score['campaign_id']}: ${new_budget:.2f}")

# Run weekly
manager = BudgetManager(client, total_budget=20000.0)
scheduler.add_job(manager.allocate_budget, trigger='cron', day_of_week='mon')
```

### Predictive Analytics

Forecast campaign performance:

```python
import numpy as np
from sklearn.linear_model import LinearRegression

def forecast_campaign_performance(campaign_id, days_ahead=7):
    # Get historical performance data
    history = client.get_performance_history(
        campaign_id,
        days=30
    )
    
    # Prepare data
    X = np.array(range(len(history))).reshape(-1, 1)
    y_roas = np.array([d['roas'] for d in history])
    y_spend = np.array([d['spend'] for d in history])
    
    # Train models
    roas_model = LinearRegression().fit(X, y_roas)
    spend_model = LinearRegression().fit(X, y_spend)
    
    # Forecast
    future_X = np.array(range(len(history), len(history) + days_ahead)).reshape(-1, 1)
    forecast_roas = roas_model.predict(future_X)
    forecast_spend = spend_model.predict(future_X)
    
    return {
        'forecast_roas': forecast_roas.tolist(),
        'forecast_spend': forecast_spend.tolist(),
        'confidence': roas_model.score(X, y_roas)
    }

# Usage
forecast = forecast_campaign_performance('camp_123', days_ahead=7)
print(f"Predicted ROAS in 7 days: {forecast['forecast_roas'][-1]:.2f}x")
```


### Integration with Analytics Platforms

Send data to Google Analytics, Mixpanel, etc.:

```python
from google.analytics.data_v1beta import BetaAnalyticsDataClient
from google.analytics.data_v1beta.types import RunReportRequest

def sync_to_google_analytics(campaign_id):
    # Get campaign performance
    metrics = client.get_performance(campaign_id)
    
    # Send to Google Analytics
    ga_client = BetaAnalyticsDataClient()
    
    # Track custom events
    ga_client.track_event(
        event_name='campaign_performance',
        parameters={
            'campaign_id': campaign_id,
            'roas': metrics['roas'],
            'spend': metrics['total_spend'],
            'conversions': metrics['total_conversions']
        }
    )

# Run daily
scheduler.add_job(
    sync_to_google_analytics,
    args=['camp_123'],
    trigger='cron',
    hour=0
)
```

---

## Quick Reference

### Essential API Calls

```python
# Create campaign
campaign = client.create_campaign(
    business_goal="increase_sales",
    monthly_budget=5000.0,
    target_audience="small business owners",
    products=["Product Name"]
)

# Get campaign status
status = client.get_campaign(campaign['campaign_id'])

# Get performance
metrics = client.get_performance(campaign['campaign_id'])

# Optimize campaign
result = client.optimize_campaign(
    campaign['campaign_id'],
    optimization_type='auto'
)

# Update campaign
client.update_campaign(
    campaign['campaign_id'],
    budget=7500.0,
    status='paused'
)

# List campaigns
campaigns = client.list_campaigns(status='active')

# Export data
data = client.export_campaign_data(campaign['campaign_id'])
```

### Key Metrics to Monitor

| Metric | Good | Warning | Critical |
|--------|------|---------|----------|
| ROAS | > 3.0x | 1.0-3.0x | < 1.0x |
| CTR | > 3% | 1-3% | < 1% |
| Conversion Rate | > 5% | 2-5% | < 2% |
| Win Rate (Bidding) | 20-40% | 10-20% or 40-60% | < 10% or > 60% |

### Common Error Codes

| Code | Status | Meaning | Action |
|------|--------|---------|--------|
| `AUTHENTICATION_FAILED` | 401 | Invalid API key | Check API key |
| `VALIDATION_ERROR` | 400 | Invalid request | Fix request parameters |
| `NOT_FOUND` | 404 | Resource not found | Verify campaign ID |
| `RATE_LIMIT_EXCEEDED` | 429 | Too many requests | Implement rate limiting |
| `AGENT_TIMEOUT` | 504 | Agent timeout | Retry request |
| `INTERNAL_SERVER_ERROR` | 500 | Server error | Contact support |


### Optimization Checklist

Before launching a campaign:
- ‚úÖ Set clear, measurable goals
- ‚úÖ Provide detailed audience description
- ‚úÖ Allocate sufficient budget ($500+ minimum)
- ‚úÖ Ensure conversion tracking is installed
- ‚úÖ Optimize landing page for conversions
- ‚úÖ Set up performance monitoring
- ‚úÖ Configure alerts for critical thresholds

After launching:
- ‚úÖ Wait 24-48 hours before making changes
- ‚úÖ Monitor ROAS daily
- ‚úÖ Review performance breakdowns weekly
- ‚úÖ Trigger optimization when ROAS < 1.5
- ‚úÖ Scale winners (ROAS > 3.0)
- ‚úÖ Pause losers (ROAS < 0.5 after 100 clicks)
- ‚úÖ Refresh creatives monthly

---

## Support and Resources

### Documentation
- **[API Reference](./openapi_enhancements.md)** - Complete API specification
- **[Integration Patterns](./integration_patterns.md)** - Common workflows
- **[Code Examples](./examples/)** - Python, JavaScript, cURL examples

### Getting Help

**Technical Support:**
- Email: api-support@example.com
- Response time: < 24 hours
- Include: API request/response, error messages, campaign ID

**Community:**
- Forum: https://community.example.com
- Discord: https://discord.gg/example
- Stack Overflow: Tag `ad-intelligence-api`

**Status and Updates:**
- Status Page: https://status.example.com
- Changelog: https://docs.example.com/changelog
- API Updates: Subscribe to api-updates@example.com

### Additional Resources

**SDKs:**
- [Python SDK](https://github.com/example/python-sdk)
- [JavaScript SDK](https://github.com/example/js-sdk)
- [Ruby SDK](https://github.com/example/ruby-sdk)

**Tools:**
- [Postman Collection](https://www.postman.com/example/collections)
- [OpenAPI Spec](./openapi_enhancements.md)
- [Webhook Tester](https://webhook-tester.example.com)

**Learning:**
- [Video Tutorials](https://youtube.com/example)
- [Webinars](https://example.com/webinars)
- [Case Studies](https://example.com/case-studies)

---

## Feedback

We're constantly improving this guide. Have suggestions?

- **Documentation Issues**: docs@example.com
- **Feature Requests**: https://feedback.example.com
- **Bug Reports**: https://github.com/example/api-issues

---

**Last Updated**: 2024-01-15  
**API Version**: v1.0.0  
**Guide Version**: 1.0

